---
title: 正则表达式
date: 2022-10-13 15:43:24
sidebar: 'auto'
categories: 
 - 团队文档
tags: 
 - 正则
---

### 基本概念
#### 什么是正则
> 正则表达式（Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。搜索模式可用于文本搜索和文本替换。它用一系列字符定义搜索模式。

#### 基本用途
- 表单输入验证
- 搜索和替换
- 过滤文本信息
- 贪婪匹配
- ...

### 创建方式
js中创建正则表达式的方式主要有两种：
**1. 字面量：**
正则表达式直接放在`/ /`之中：

```javascript
const regexp = /ABC\-001/g
/正则表达式主体/修饰符(可选)
```

**2.构造函数：** RegExp对象表示正则表达式的一个实例
```javascript
const regex = new RegExp('ABC\\-001','g')
// new RegExp('正则表达式主体','修饰符')
```
注意，如果使用第二种写法，因为字符串转义的问题，字符串中的两个`\\`实际上是一个`\`


#### 字符集合: []
[]: 会匹配包含的任意一个字符.
假设我需要匹配，a,b,c这些类型的字符，就可以通过使用`[字符集合]`来处理
```javascript
const regexp = new RegExp('[abc]')
'adsdasdcvvbsc'.match(regexp)
```
`[^]`: 括号中以`^`开头，表示取反

#### 字符范围: [a-z]
常见的字符范围有：
- [部分范围]：`[a-f]`，匹配a到f的任意字符
- [小写范围]：`[a-z]`，匹配a到z的任意字符
- [大写范围]：`[A-Z]`，匹配A到Z的任意字符
- [数字范围]：`[0-9]`，匹配0到9的任意字符
- [符号范围]：`[#$%&@]`
- [混合范围]：`[a-zA-Z0-9]`，匹配所有数字、大小写字母中的任意字符

#### 数字字符
如果想要匹配三个字母的单词，根据上面我们学到的字符范围，可以这样来写
```javascript
[a-z][a-z][a-z]
```

这里我们匹配的三个字母的单词，那如果想要匹配10个、20个字母的单词呢？难道要一个个来写范围吗？有一种更好的方法就是使用花括号`{}`来表示，来看例子：
```javascript
[a-z]{5}
// 表示要连续匹配到5个小写字母
```

匹配重复字符的完整语法是这样的：`{m,n}`，它会匹配前面一个字符至少 `m` 次至多 `n` 次重复，`{m}`表示匹配 `m` 次，`{m,}`表示至少 `m` 次。

#### 元字符

- `\d`：相当于`[0-9]`，匹配任意数字
- `\D`：相当于`[^0-9]`
- `\w`：相当于`[0-9a-zA-Z]`，匹配任意数字、大小写字母和下划线
- `\W`：相当于`[^0-9a-zA-Z]`
- `\s`：相当于`[\t\v\n\r\f]`，匹配任意空白符，包括空格，水平制表符`\t`，垂直制表符`\v`，换行符`\n`，回车符`\r`，换页符`\f`
- `\S`：相当于`[^\t\v\n\r\f]`，表示非空白符

#### 特殊字符

使用特殊字符可以编写更高级的模式表达式，常见的特殊字符如下：

- `.`：匹配除了换行符之外的任何单个字符,**慎用**~
- `\`：将下一个字符标记为特殊字符、或原义字符、或向后引用、或八进制转义符
- `|`：逻辑或操作符
- `[^]`：取非，匹配未包含的任意字符

#### 位置匹配

常见的位置匹配如下：
- `^`：匹配开头，在多行匹配中匹配行开头,`^abc` 表示匹配有 `abc` 开头的字符串
- `$`：匹配结尾，在多行匹配中匹配行结尾,`^\d$` 表示匹配一个 `[0-9]` 的数字
- `\b`：匹配一个单词边界，也就是指单词和空格间的位置,`er\b` 可以匹配 `never` 中的 `er`，但不能匹配 `verb` 中的 `er`
- `\B`：匹配非单词边界, `er\B` 不可以匹配 `never` 中的 `er`，但能匹配 `verb` 中的 `er`
- `(?=p)`：匹配 p 前面的位置
- `(?!=p)`：匹配不是 p 前面的位置

### 匹配规则
整理了部分常见的匹配规则，具体如下：
|  字符  | 说明  |  例子  |
|  ----  | ----  | ----  |
| `\`  | 将下一个字符标记为特殊字符 | `\n` 表示换行符、`\d `匹配 [0-9] 的数字 |
| `^`  | 匹配字符串的开始位置 | `^abc` 表示匹配有 `abc` 开头的字符串 |
| `$`  | 匹配字符串的结束位置 | `^\d$` 表示匹配一个 `[0-9]` 的数字 |
| `*`  | 匹配前面的子表达式零次或多次 | `zo*` 能匹配 `z` 或者 `zoo` |
| `+`  | 匹配前面的子表达式一次或多次 | `zo+` 能匹配 `zo` 或者 `zoo`，但不能匹配 `z` |
| `?`  | 匹配前面的子表达式零次或一次 | `do(es)?` 可以匹配 `does` 或 `do` |
| `{n}`  | n是一个非负整数。匹配确定的 n 次 | `o{2}`不能匹配`Bob`中的`o`，但是能匹配 `food` 中的两个 `o` |
| `{n,}`  | n是一个非负整数。至少匹配 n 次 | ` o{2,}`不能匹配`Bob`中的`o`，但能匹配`foooood` 中的所有`o`。`o{1,}` 等价于`o+`。`o{0,}` 则等价于 `o*` |
| `{n,m}`  | m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次 | `o{1,3}` 将匹配`fooooood`中的前三个`o`。`o{0,1}` 等价于`o?`。逗号和两个数之间不能有空格 |
| `x|y`  | 匹配 x 或者 y | `z|food` 能匹配 `z` 或者 `food`。`(z|f)ood` 则匹配 `zood` 或 `food`|
| `[xyz]`  | 匹配所包含的任意一个字符 | `[abc]`可以匹配`plain`中的 `a` |
| `[^xyz]`  | 求反。匹配未包含的任意字符 | `[^abc]` 可以匹配`plain` 中的除`a`外的其他字符 |
| `[a-z]`  | 字符范围。匹配指定范围内的任意字符 | `[a-z]` 可以匹配 `a` 到 `z` 范围内的任意小写字母字符。注意：[A-Z] 才匹配大写英文字母,`[^a-z]`则是取反 |
| `\b`  | 匹配一个单词边界，也就是指单词和空格间的位置 | `er\b` 可以匹配 `never` 中的 `er`，但不能匹配 `verb` 中的 `er` |
| `\B`  | 匹配非单词边界 | `er\B` 不可以匹配 `never` 中的 `er`，但能匹配 `verb` 中的 `er` |
| `\d`  | 匹配一个数字字符。等价于[0-9] | `\d` 能匹配 `4 = IV` 中的 `4` |
| `\D`  | 匹配一个非数字字符。等价于[^0-9] | `\D` 能匹配 `4 = IV` 中的 `=、I、v` |
| `\n`  | 匹配一个换行符。等价于`\x0a`和`\cJ` | `\r\n(\w+)` 能匹配 `\r\nThese are\ntwo lines` 中的 `\r\nThese` |
| `\r`  | 匹配一个回车符。等价于`\x0d`和`\cM` | `\r\n(\w+)` 能匹配 `\r\nThese are\ntwo lines`. 中的 `\r\nThese` |
| `\w`  | 匹配包括下划线的任何单词字符。等价于 `[A-Za-z0-9_]` | `ID A1.3` 中的 `I、D、A、1、3` |
| `\W`  | 匹配任何非单词字符。等价于 `[^A-Za-z0-9_]` | `ID A1.3` 中的 `.` |

### 匹配优先级
1. `\`：转义符
2. `()`，`(?:)`，`(?=)`，`[]`
3. `*`，`+`，`?`，`{n}`，`{n,}`，`{n,m}`
4. `^`，`$`
5. `|`

### 修饰符
正则表达式常见的修饰符如下：

- `g`：表示全局模式，即运用于所有字符串
- `i`：表示不区分大小写，即匹配时忽略字符串的大小写
- `m`：表示多行模式，强制 `$`和 `^` 分别匹配每个换行符

### RegExp 实例方法

RegExp 实例置了`test()`和`exec()` 这两个方法来校验正则表达式。下面来分别看一下这两个方法
1. `test()`: 用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。
```javascript
const regex1 = /a/ig;
const regex2 = /hello/ig;
const str = "Action speak louder than words";

console.log(regex1.test(str));  // true
console.log(regex2.test(str));  // false
```

2. `exec()`: 用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null
```javascript
const regex1 = /a/ig;
const regex2 = /hello/ig;
const str = "Action speak louder than words";

console.log(regex1.exec(str));  // ['A', index: 0, input: 'Action speak louder than words', groups: undefined]
console.log(regex2.exec(str));  // null
```

### 字符串方法
在 JavaScript 中有6种常用的方法是支持正则表达式的，下面来分别看看这些方法
1. search()
`search()` 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。如果没有找到任何匹配的子串，则返回 -1
```javascript
const regex1 = /a/ig;
const regex2 = /p/ig;
const regex3 = /m/ig;
const str = "Action speak louder than words";

console.log(str.search(regex1));  // 输出结果：0
console.log(str.search(regex2));  // 输出结果：8
console.log(str.search(regex3));  // 输出结果：-1
```
2. match()
`match()` 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。如果没有找到任何匹配的文本， `match()` 将返回 `null`。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。
```javascript
const regex1 = /a/ig;
const regex2 = /a/i;
const regex3 = /m/ig;
const str = "Action speak louder than words";

console.log(str.match(regex1));  // 输出结果：['A', 'a', 'a']
console.log(str.match(regex2));  // 输出结果：['A', index: 0, input: 'Action speak louder than words', groups: undefined]
console.log(str.match(regex3));  // 输出结果：null
```
3. matchAll()
`matchAll()` 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。因为返回的是遍历器，所以通常使用`for...of`循环取出。
```javascript
for (const match of 'abcabc'.matchAll(/a/g)) {
    console.log(match)
}
//["a", index: 0, input: "abcabc", groups: undefined]
//["a", index: 3, input: "abcabc", groups: undefined]
```
4. replace()
`replace()` 用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串

```javascript
const regex = /A/g;
const str = "Action speak louder than words";

console.log(str.replace(regex, 'a'));  // 输出结果：action speak louder than words
```
5. replaceAll()
`replaceAll()` 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串，该函数会替换所有匹配到的子字符串
```javascript
const regex = /a/g;
const str = "Action speak louder than words";

console.log(str.replaceAll(regex, 'A'));  // 输出结果：Action speAk louder thAn words
```
6. split()
`split()` 方法用于把一个字符串分割成字符串数组。其第一个参数是一个字符串或正则表达式，从该参数指定的地方分割字符串

```javascript
const regex = / /gi;
const str = "Action speak louder than words";

console.log(str.split(regex));  // 输出结果：['Action', 'speak', 'louder', 'than', 'words']
```

### 常用的正则

#### 匹配邮箱
```javascript
/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[ a-zA-Z0-9-]+)*$/g
```
下面来看一下这个正则表达式每一部分的含义：
- `^[a-zA-Z0-9.!#$%&'*+/=?^_{|}~-]+`：检查是否使用了所有有效字符并且至少有了一个,最后的 `+` 表示至少有一位；
- `[a-zA-Z0-9-]+`：这一部分用来检验主机名是否有效，主机名可以是大小写字母、数字、中横线。最后的 `+` 表示至少有一位；
- `(?:\.[a-zA-Z0-9-]+)*`：这一部分是可选的域名后缀，这里使用的 `*`就表示前面的字符是0个或者多个，这样`.com`、`.com`,`.cn`等域名都可以匹配到
- `^`和`$`可以保证匹配从字符串的开头到结尾进行匹配，也就是只对整个邮箱字符串进行匹配，不考虑部分匹配

#### 匹配身份证
```javascript
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})(\d{2})(\d)(\d|X)$/;
```
- `(\d{6})`: 前6位代表省市区/县，可以查询出来所有结果
- `(\d{4})(\d{2})(\d{2})`：接着8位是出生年月日
- `(\d{2})`: 接着2位是签发机关编码
- `(\d)(\d|X)`: 倒数第二位代表性别，基数是男，偶数是女，最后一位可以是X

#### 匹配手机号
```javascript
let reg = /^1(3\d|4[5-9]|5[0-35-9]|6[567]|7[0-8]|8\d|9[0-35-9])\d{8}$/
```
### 贪婪模式
>贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎所支持。

属于贪婪模式的量词，也叫做匹配优先量词，包括：
`{m,n}`、`{m,}`、`?`、`+`、`*`

从应用的角度，回答一下“什么是贪婪与非贪婪模式？”
举个栗子：
源字符串：`aa<div>test1</div>bb<div>test2</div>cc`
正则表达式一：`<div>.*</div>`
匹配结果一：`<div>test1</div>bb<div>test2</div>`
正则表达式二：`<div>.*?</div>`
匹配结果二：`<div>test1</div>`（这里指的是一次匹配结果，所以没包括<div>test2</div>）

仅从应用角度分析，可以这样认为，贪婪模式，就是在整个表达式匹配成功的前提下，尽可能多的匹配，也就是所谓的“贪婪”，通俗点讲，就是看到想要的，有多少就捡多少，除非再也没有想要的了。非贪婪模式，就是在整个表达式匹配成功的前提下，尽可能少的匹配，也就是所谓的“非贪婪”，通俗点讲，就是找到一个想要的捡起来就行了，至于还有没有没捡的就不管了。

总结：

- 贪婪匹配：匹配上从第一个到最后一个之间的所有符合条件的内容
- 非贪婪匹配：找到一个符合条件的内容即返回

### 在线正则网址
平时业务开发中，使用正则时，需要各类情况都考虑周全。除简单的匹配和替换文本，其他不建议个人手写正则，费时且可能遗漏匹配情况，推荐使用在线网址查阅，例如[站长工具](https://tool.chinaz.com/regex)。常用的邮箱，手机号，网址检测，可以自己记录笔记，便于查阅。

那有同学说了，那你还上面讲解这么多废话？

首先咱们学习正则，可以拓展技术池；其次在了解其用法后去找对应的正则，可以看得懂正则的意思，在有错误的时候，也可以尽快发现并解决。
