---
title: Event Loop
date: 2021-04-25 22:29:06
sidebar: 'auto'
categories: 
 - 日常笔记
---
### 前言
众所周知，javscript是`单线程`，但是为什么单线程又有`异步`的能力。本文从`线程`、`进程`的角度来解释这个问题。

### CPU
计算机的核心是CPU，计算机所有的计算都是由它负责。它就像一座工厂，时刻在运行。

### 进程
工厂的电力有限，一次只能供给一个车间使用。每次车间开工的时候，其他车间必须停工。即单个CPU一次只能运行一个任务。

`进程`就像是工厂的车间，它代表CPU所能处理的单个任务。`进程`之间相互独立，任意时刻，CPU总是运行一个`进程`，CPU通过时间片轮转法来实现同时运行多个`进程`

### 线程
每个车间，都可以有很多工人，共享车间的资源，他们协同完成一个任务。

`线程`就好比车间里的工人，一个`进程`可以包括多个`线程`，多个`线程`共享`进程`资源。

### CPU、进程、线程之间的关系
- `进程`是cpu资源分配的最小单位，每个应用程序就是一个`进程`
- `线程`是cpu调度的最小单位
- 不同`进程`之间也可以通信，但是相对复杂
- `单线程`和`多线程`是指在一个`进程`内的单和多
### 浏览器
当我们在浏览器打开多个tab时，打开控制管理器，可以看到一个谷歌浏览器启动了多个进程。所以大致可以知道，浏览器时多进程的，每个tab页就是个独立的进程。

### 浏览器的渲染进程
浏览器的渲染进程也包括多个线程
- `GUI渲染线程`
    - 负责渲染页面，布局和绘制
    - 页面需要重绘和回流时，该线程就会执行
    - 与js引擎线程互斥，防止渲染结果不可预期
- `JS引擎线程`
    - 负责处理解析和执行JavaScript脚本程序
    - 只有一个JS引擎线程（单线程）
    - 与GUI渲染线程互斥，防止渲染结果不可预期
- `事件触发线程`
    - 用来控制事件循环，鼠标点击，setTimeout，ajax等
    - 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中
- `定时触发器线程`
    - setInterval与setTimeout所在线程
    - 计时完毕后，通知事件触发线程
- `异步http请求线程`
    - 浏览器有个单独的线程用来处理ajax请求
    - 请求完成时，若有回调函数，通知事件触发线程
    
当了解以上渲染进程包含的这些线程后，我们就可以知道：
1. 为什么JavaScript要设计成单线程的
2. 为什么GUI渲染线程与JS引擎线程互斥

### 为什么JavaScript要设计成单线程的
1. 多线程操作需要加锁，编码的复杂性更高
2. JavaScript最初是解决用户交互的，如果同时操作DOM。在多线程不加锁的情况下，最终会导致DOM的渲染结果不可预期

### 为什么GUI渲染线程与JS引擎线程互斥
JavaScript可以操作DOM元素，如果同时修改元素属性，并同时渲染界面，那么最终可能导致前后获得的元素不一致。
所以当`JS引擎线程`执行时，`GUI渲染线程`会被挂起，GUI更新则会保存在一个队列中，等待`JS引擎线程`空闲时间立即被执行。
### Event Loop
 先了解一些概念：
- JS分为同步任务和异步任务
- 同步任务都在JS引擎线程上执行，形成一个`执行栈`
- 事件触发线程管理一个`任务对列`，异步任务触发条件达成，将回调事件放到`任务对列`中
- `执行栈`中所有的同步任务执行完毕，此时JS引擎线程空闲，系统会读取`任务对列`，将可运行的异步任务回调事件添加到`执行栈`中，开始执行

前端开发中我们通过`setTimeout/setInterval`和`XHR/fetch`发送网络请求，其实不管是`setTimeout/setInterval`还是`XHR/fetch`。这些代码被执行时，本身是同步任务，而其中的回调函数才是异步任务。

当代码执行到`setTimeout/setInterval`时，`JS引擎线程`通知`定时器触发线程`，间隔一段时间后会触发一个回调事件，而`定时器触发线程`在接收到这个消息后，并在等待时间后，将回调事件放入到由`事件触发线程`所管理的`事件对列`中。

当代码执行到`XHR/fetch`时，`JS引擎线程`通知`异步http请求线程`，发送一个网络请求，并制定请求完成的回调事件。而`异步http请求线程`在接收到这个消息后，会在请求成功后，将回调事件放入到由`事件触发线程`所管理的`事件对列`中。

当我们的同步任务执行完，`JS引擎线程`会询问`事件触发线程`，在事件对列中是否有待执行的回调函数，如果有就加入到执行栈中交给`JS引擎线程`执行

有点长，总结一下：
- JS引擎线程只执行`执行栈`中的事件
- 执行栈中的代码执行完毕，就读取事件对列中的事件
- 事件对列中的回调事件，是由各自线程插入到事件对列中的
### 宏任务、微任务
#### 什么是宏任务
我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件对列中获取一个事件并放到执行栈中执行)，每一个宏任务会从到到尾执行完毕。

我们前文提到过的`JS引擎线程`和`GUI渲染线程`是互斥关系，浏览器为了能够使宏任务和DOM任务有序进行，会在一个宏任务执行结果后，在下一个宏任务执行💰，`GUI渲染线程`开始工作，渲染页面

宏任务 => 渲染 => 宏任务 => 渲染 => 渲染 ....

主代码块，setTimeout，setInterval等，都属于宏任务
### 什么是微任务
我们知道了宏任务结束后，会执行渲染，然后执行下一个微任务，而微任务可以理解成当前宏任务执行后立即执行的任务。

也就是说，当宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完。Promise，process.nextTick等，都是微任务。
### 总结
- 执行一个宏任务，栈中没有就从事件对列中获取
- 执行过程中如果遇到微任务，就将它添加到微任务对列中
- 宏任务执行完毕后，立即依次执行当前微任务对列中的所有微任务
- 当前宏任务执行完毕，开始检查渲染，然后GUI线程渲染
- 渲染完毕后，JS线程继续接管，开始下个宏任务 